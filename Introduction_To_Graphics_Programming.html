<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Introduction To Graphics Programming</title>
  <meta name="description" content="">
  <meta name="keywords" content="">

  <!-- Favicons -->
  <link href="assets/img/favicon.png" rel="icon">
  <link href="assets/img/apple-touch-icon.png" rel="apple-touch-icon">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com" rel="preconnect">
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Raleway:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
    rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="assets/vendor/aos/aos.css" rel="stylesheet">
  <link href="assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">
  <link href="assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">

  <!-- Main CSS File -->
  <link href="assets/css/main.css" rel="stylesheet">

  <!-- =======================================================
  * Template Name: Personal
  * Template URL: https://bootstrapmade.com/personal-free-resume-bootstrap-template/
  * Updated: Nov 04 2024 with Bootstrap v5.3.3
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
  ======================================================== -->
</head>

<body class="portfolio-details-page">

  <header id="header" class="header d-flex align-items-center fixed-top">
    <div class="container-fluid container-xl position-relative d-flex align-items-center justify-content-between">

      <a href="index.html" class="logo d-flex align-items-center">
      </a>

      <nav id="navmenu" class="navmenu">
        <ul>
          <li><a href="index.html">Home</a></li>
          <li><a href="about.html">About</a></li>
          <li><a href="resume.html">Resume</a></li>
          <li><a href="portfolio.html">Portfolio</a></li>
          <li><a href="contact.html" class="active">Contact</a></li>
        </ul>
        <i class="mobile-nav-toggle d-xl-none bi bi-list"></i>
      </nav>

    </div>
  </header>

  <main class="main">

    <!-- Page Title -->
    <div class="page-title" data-aos="fade">
      <nav class="breadcrumbs">
        <div class="container">
          <ol>
            <li><a href="index.html">Home</a></li>
            <li class="current">Introduction To Graphics Programming</li>
          </ol>
        </div>
      </nav>
    </div><!-- End Page Title -->

    <!-- Portfolio Details Section -->
    <section id="portfolio-details" class="portfolio-details section">

      <div class="container" data-aos="fade-up" data-aos-delay="100">

        <div class="row gy-4">

          <div class="col-lg-8">
            <div class="portfolio-details-slider swiper init-swiper">

              <script type="application/json" class="swiper-config">
                {
                  "loop": true,
                  "speed": 600,
                  "autoplay": {
                    "delay": 5000
                  },
                  "slidesPerView": "auto",
                  "pagination": {
                    "el": ".swiper-pagination",
                    "type": "bullets",
                    "clickable": true
                  }
                }
              </script>

              <div class="swiper-wrapper align-items-center">

                <div class="swiper-slide">
                  <img src="assets/img/portfolio/OGL_0.png" alt="">
                </div>

                <div class="swiper-slide">
                  <img src="assets/img/portfolio/OGL_1.png" alt="">
                </div>

                <div class="swiper-slide">
                  <img src="assets/img/portfolio/OGL_2.png" alt="">
                </div>

                <div class="swiper-slide">
                  <img src="assets/img/portfolio/OGL_3.png" alt="">
                </div>

                <div class="swiper-slide">
                  <img src="assets/img/portfolio/OGL_4.png" alt="">
                </div>

                <div class="swiper-slide">
                  <img src="assets/img/portfolio/OGL_5.png" alt="">
                </div>

                <div class="swiper-slide">
                  <img src="assets/img/portfolio/OGL_6.png" alt="">
                </div>

              </div>
              <div class="swiper-pagination"></div>
            </div>
          </div>

          <div class="col-lg-4">
            <div class="portfolio-info" data-aos="fade-up" data-aos-delay="200">
              <h3>Project information</h3>
              <ul>
                <li><strong>Topic</strong>: Graphic Programming</li>
                <li><strong>API</strong>: OpenGL</li>
                <li><strong>Project date</strong>: 2024</li>
                <li><strong>Video</strong>: <a href="https://youtu.be/3IeOt4Ab08s?si=khe9_jkExFj1PLH8"> Link </a></li>
                <li><strong>Academic Project</strong></li>
              </ul>
            </div>
            <div class="portfolio-description" data-aos="fade-up" data-aos-delay="300">
              <h2>About the Project</h2>
              <p>
                My first approach to a graphics API. This exercise has enabled significant personal innovation, as it
                required developing new techniques and approaches with which I personally had no prior experience. It
                also expanded the artistic possibilities for all my future projects. As for the implementation, I am
                proud of the efficiency and cleanliness of much of the code.
              </p>
            </div>
          </div>

        </div>
        <br>
        <h1>Most Important Implementations</h1>
        <br>
        <p>During the completion of this exercise, a basic abstraction layer was implemented over some of the
          fundamental OpenGL tools such as shaders, programs, buffers, textures, etc. The rest of the implementations
          were developed on top of this layer, with some of the most important being:
        </p>
        <br>
        <h4>Procedural Generation of an Infinite Terrain:</h4><br>
                <video autoplay loop muted playsinline  style="width: 70%; height: auto; transform: translateX(15%);" preload="auto">
          <source src="assets/img/portfolio/Explanations/OGL_exp_0.mp4" type="video/mp4">
        </video>
        <p>Nine terrain tiles are used (three rows and three columns) that are repositioned to always keep the user at
          the center, using multithreading for fast generation of each tile. When the terrain detects that the user is
          no longer in the center, three of the tiles are moved and recalculated toward the new nearest side using
          Perlin noise.
        </p>
        <br>
        <pre>
last_center.x = pos_.x;
		
new_pos.x = last_center.x + terrain_size_;
	
new_pos.y = last_center.y;
thread_system_->AddTask(std::bind(ReuploadVertexTerrain, terrains[3].get(), terrain_drawable[3].get(), height_mult_, quad_size_, new_pos, noise_size_));
UpdateVegetations(vegetation_entities[3].get(), new_pos);

new_pos.y = last_center.y - terrain_size_;
thread_system_->AddTask(std::bind(ReuploadVertexTerrain, terrains[0].get(), terrain_drawable[0].get(), height_mult_, quad_size_, new_pos, noise_size_));
UpdateVegetations(vegetation_entities[0].get(), new_pos);

new_pos.y = last_center.y + terrain_size_;
thread_system_->AddTask(std::bind(ReuploadVertexTerrain, terrains[6].get(), terrain_drawable[6].get(), height_mult_, quad_size_, new_pos, noise_size_));
UpdateVegetations(vegetation_entities[6].get(), new_pos);
        </pre>
        <br>
        <p>Then they are uploaded to the GPU, and a swap is performed in the array to always keep track of the positions
          each one occupies.
        </p>
        <br>
        <pre>
terrains[3]->reuploadData();
terrains[0]->reuploadData();
terrains[6]->reuploadData();

terrains[0].swap(terrains[1]);
terrains[1].swap(terrains[2]);

terrains[3].swap(terrains[4]);
terrains[4].swap(terrains[5]);

terrains[6].swap(terrains[7]);
terrains[7].swap(terrains[8]);
        </pre>
        <br>
        <br>
        <br>
        <h4>Navigating a Procedural Terrain Without Using Physics:</h4>
        <br>
                <video autoplay loop muted playsinline  style="width: 70%; height: auto; transform: translateX(15%);" preload="auto">
          <source src="assets/img/portfolio/Explanations/OGL_exp_1.mp4" type="video/mp4">
          </video>
        <p>First, controls are mapped so that the user can operate the vehicle, using a few tricks to give the car
          weight and acceleration; all of this is processed every frame.
        </p>
        <br>
        <pre>
bool in_movement = (speed_ > 0.1f || speed_ < -0.1f);
if (in_movement) {
    //CarRotation
    UpdateChasisRotation(...); //To Left or Right
}
bool accelerating = false;
if (IsSpecialKeyPressed(kSpecialKey_Up)) {
    //Accelerate
}
else if (IsSpecialKeyPressed(kSpecialKey_Down)) {
    //SlowDown
}
else if (in_movement){
    //Inertia
}
else {
    //Stoped
}
float new_car_pos[3];
new_car_pos = ...;
car_parent->set_position(new_car_pos);
        </pre>
        <br>
        <p>Then, to simulate movement over an uneven surface, the same noise applied to the terrain is used to calculate
          the vehicle's position and tilt.
        </p>
        <br>
        <pre>
float chasis_pos[3];
chasis_pos[0] = 0;
chasis_pos[1] = 0;
chasis_pos[2] = 0;
float y_positions[4];

for (int i = 0; i < 4; i++) {
    y_positions[i] = ...; //Height of each wheel
    chasis_pos[1] += y_positions[i]; //Average Height For the Main Frame
}

Vec3 front;
Vec3 back;
Vec3 righ_side;
Vec3 left_side;

Vec3 forward;
Vec3 right;

//Middle point of the front
front = ...;

//Middle point of the back
back = ...;

// Vector forward
forward = back - front;

// Middle point of the left
left_side = ...;

// Middle point of the right
righ_side = ...;

//Vector right
right = righ_side - left_side;

float x_rotation = Vec3::Angle(forward, Vec3::up);
float z_rotation = Vec3::Angle(right, Vec3::up);
parts[0]->set_position(chasis_pos);
parts[0]->set_rotation_xyz(x_rotation, 0.0f, z_rotation);
        </pre>
        <br>
        <br>
        <br>
        <h4>Post-processing: Outline & DOF</h4>
        <p>The depth buffer is used for both post-processing effects: in the first, to detect the edges of different
          objects (applying an outline, in this case black), and in the second, to blend between a blurred and a focused
          render, achieving the desired effect.
        </p><br>
                        <video autoplay loop muted playsinline  style="width: 70%; height: auto; transform: translateX(15%);" preload="auto">
          <source src="assets/img/portfolio/Explanations/OGL_exp_2.mp4" type="video/mp4">
          </video>
        <br>
        <h6>Outline:</h6>
        <pre>
void main() {
  float minDistance   = 0.8;
  float maxDistance   = 1.0;
  int   size          = 10;
  vec3  colorModifier = vec3(0.0, 0.0, 0.0);
  vec2 texCoord;

  vec4 color = texture(u_focus_texture, uv_);

  vec4 position     = texture(u_z_posotion_texture, uv_);
  position.x = smoothstep(minDistance, maxDistance, position.x);
  position.y = smoothstep(minDistance, maxDistance, position.y);
  position.z = smoothstep(minDistance, maxDistance, position.z);
  vec4 positionTemp = position;


  float separation = 0.0002;
  float mx         = 0.0;

  for (int i = -size; i <= size; ++i) {
    for (int j = -size; j <= size; ++j) {
      texCoord =
          (vec2(i, j) * separation + (uv_));

      positionTemp =
        texture
          ( u_z_posotion_texture
          , texCoord
          );

      positionTemp.x = smoothstep(minDistance, maxDistance, positionTemp.x);
      positionTemp.y = smoothstep(minDistance, maxDistance, positionTemp.y);
      positionTemp.z = smoothstep(minDistance, maxDistance, positionTemp.z);

      //if (positionTemp.x <= 0.0) { positionTemp.x = 1.0; }

      mx = max(mx, abs(position.x - positionTemp.x));
    }
  }
  float diff         = smoothstep(0, 0.02, mx);

  vec3 lineColor  = texture(u_focus_texture, uv_).rgb;
       lineColor *= colorModifier;

  fragColor.rgb = mix(color.rgb, lineColor, diff);
  fragColor.a   = 1.0;
}
        </pre>
        <br>
        <h6>DOF:</h6>
        <pre>
void main() { 
  
  float min_distance =  0.0;
  float max_distance = 0.05;

  vec2 tex_size  = textureSize(u_focus_texture, 0).xy;
  vec4 focus_color = texture(u_focus_texture, uv_);

  vec4 position = texture(u_z_posotion_texture, uv_);

  vec4 out_of_focus_color = texture(u_out_focus_texture, uv_);
  vec4 focus_point = texture(u_z_posotion_texture, u_focus_point);

  float blur =
    smoothstep
      ( min_distance
      , max_distance
      , abs(position.x - focus_point.x)
      );

  frag_color  = mix(focus_color, out_of_focus_color, blur);
}
        </pre>
        <br>
        <br>
        <br>
        <h4>CPU-Based Particle System:</h4>
        <p>Finally, a CPU-based particle system was implemented to simulate the dust kicked up by the car while driving
          over the terrain. In this case, spherical particles were used instead of the typical billboarding quads to
          achieve greater visual cohesion with the rest of the elements, although they are considerably more
          performance-intensive.
        </p>
        <br>
        <p>First the geometric foundation is created by generating spherical meshes using parametric equations. It
          calculates 11 height and 11 revolution steps to form each sphere's surface, computing 3D positions with
          spherical coordinates, normals, and UV coordinates for every vertex. This sphere geometry is replicated for
          each particle in the system. The function then builds an index buffer defining how vertices connect into
          triangles and uploads all this data to GPU buffers. Finally, it allocates space for 100 particles with
          configurable lifetimes.
        </p>
        <br>
        <pre>
for (int rep = 0; rep < num_particles_system_; rep++) {
	for (int i = 0; i < num_heights_; i++) {
		radio = cos(height_angle * i - (3.14159265f * 0.5f));
		aux_vec3.y = sin(height_angle * i - (3.14159265f * 0.5f));
		aux_uv.y = (0.1f) * i;
		for (int j = 0; j < num_revs_; j++) {
			aux_vec3.x = radio * cos(revs_angle * j);
			aux_vec3.z = radio * sin(revs_angle * j);
			vertex[j + (i * num_revs_) + (rep * 121)].points.x = aux_vec3.x;
			...
			vertex_updt[j + (i * num_revs_) + (rep * 121)].uv = aux_uv;
		}
	}
}

scoped_array<int> indexes;
indexes.alloc(600 * num_particles_system_);

for (int rep = 0; rep < num_particles_system_; rep++) {
	for (int i = 0; i < 10; i++) {
		for (int j = 0; j < 10; j++) {
			int ind_aux = (i * num_revs_ + j) + (rep * 121);
			indexes[((j + (i * 10)) * 6) + (rep * 600)] = ind_aux;
			...
			indexes[(((j + (i * 10)) * 6) + 5) + (rep * 600)] = ind_aux + 1;
		}
	}
}
        </pre>
        <br>
        <p>Then the update() function handles the particle lifecycle each frame. It spawns new particles at regular
          intervals when emission is active, placing them at the spawner's position with random velocities. For each
          active particle, it updates the lifetime and position based on velocity, then calculates a scale factor that
          lerps from 0.15 to 0.0 as the particle ages, creating a shrinking effect. It applies transformation matrices
          combining translation and scaling to every vertex of the base sphere geometry, effectively positioning and
          sizing each particle in 3D space. Particles that exceed their maximum lifetime are deactivated for future
          reuse. The transformed vertex data for active particles is then uploaded to the GPU for rendering.
        </p>
        <br>
      </div>

    </section><!-- /Portfolio Details Section -->

  </main>

  <!-- Scroll Top -->
  <a href="#" id="scroll-top" class="scroll-top d-flex align-items-center justify-content-center"><i
      class="bi bi-arrow-up-short"></i></a>

  <!-- Preloader -->
  <div id="preloader"></div>

  <!-- Vendor JS Files -->
  <script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="assets/vendor/php-email-form/validate.js"></script>
  <script src="assets/vendor/aos/aos.js"></script>
  <script src="assets/vendor/typed.js/typed.umd.js"></script>
  <script src="assets/vendor/purecounter/purecounter_vanilla.js"></script>
  <script src="assets/vendor/waypoints/noframework.waypoints.js"></script>
  <script src="assets/vendor/swiper/swiper-bundle.min.js"></script>
  <script src="assets/vendor/glightbox/js/glightbox.min.js"></script>
  <script src="assets/vendor/imagesloaded/imagesloaded.pkgd.min.js"></script>
  <script src="assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>

  <!-- Main JS File -->
  <script src="assets/js/main.js"></script>

</body>

</html>